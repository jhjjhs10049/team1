홍금락선생님 요구사항
테이블 연관관계
ui (어떻게 동작되는지 1구간정도)
기능 1~2개 (back + front 나눠서)
디테일 1~2개 정도
디자인패턴
mvc패턴 +util  
폴더개수 권장은 3개로 사용
테이블에 관련된 arraylist, set 등 이유

백
api
rest
토큰/OAuth2
JWT/Refresh Token

프론트
SPA
react
vite
jsx


백
1. mpa/api
pc통신시절에는 화면의 종류가 적기에 mpa방식을 사용했으나 스마트폰의 보급으로인해 화면비율이 엄청나게 다양해져 서버에서 모든 비율에 대한 처리를 하면 서버에 부담이 커지기에 서버에선 내용만 보내주고 프론트에서 화면을 구성하는 방식인 api방식을 사용하게됨 
2. rest/GraphQL/gRPC
rest는 가장 표준적이고 단순하며 추후설명할 리액트와의 연계성이 뛰어남
3. 세션 / 토큰 / OAuth2
OAuth2는 카카오 api를 사용하기위해 강제로 필요하기에 넘기고
세션은 단순하지만 상태를 저장해 직접관리해야되기에 확장성에 불리하다.
그에비해 토큰방식은 저장소없이 토큰자체만 검증하면되는 무상태 방식이며 확장성이 좋다.
4. JWT/Opaque Token/Refresh Token
 {질문대비용 : 오페이크 토큰은 랜덤문자열로서 보안은 좋지만 세션과 비슷하게 서버상태관리가 필요하기에 확장성에 약하다.} 
JWT (JSON Web Token) 토큰자체에 사용자 정보와 서명이 들어있음 api서버 구조와 호환이 좋으며 무상태방식으로 확장성에 용의하다. 다만 탈취위험이 크다는 단점이 있는데 이것을 Refresh Token을 추가하여 일정시간이 지날때마다 토큰을 초기화시켜주는 방식으로 최대한 방어하였다.



프론트
1. MPA/SPA
MPA 방식은 JSP나 XML 기반 템플릿을 사용해 화면을 구성했는데, 이는 설정이 복잡하고 프론트와 백엔드 코드가 뒤섞여 협업과 유지보수에 불리했습니다. 또한 서버가 모든 화면을 처리해야 하므로 서버 부하가 크게 걸리는 문제도 있었습니다. 반면 SPA 방식은 다양한 기기에 유연하게 대응할 수 있고, 앱처럼 부드러운 화면 전환과 높은 확장성을 제공하기 때문에 결국 SPA 방식을 선택하게 되었습니다
2. react, vue, angular 
성능자체는 상향평준화가 되어 별차이가 없으나 압도적인 사용률과 방대한 커뮤니티를 이유로 react를 사용하게 되었습니다.
3. vite, next.js
성능이 좋고 빠른 빌드때문에 vite선택
4. js, jsx, ts, tsx
타입스크립트가 대형프로젝트에서 유리하고 유지보수가 좋지만 팀원들의 숙련도를 이유로 자바스크립트를 사용하였습니다. 그중 html처럼 직관적인 화면구성을 위해 jsx방식을 사용하였습니다.


폴더구조
1. 기능별 구조
2. 카멜표기법

ERD 스키마구조 (테이블 관계도) 설명 

기능
회원가입/로그인/마이페이지/관리자페이지
게시판
gym map(혁준씨 메인기능)

* 기능소개하면서 디테일 + 코드상 문제있었던거 각각 1개씩 정도 설명필요

현재 상황은, 로그인되지 않았거나 차단(banned)된 사용자가 로그인 시도를 할 경우, 이를 거부해야 하는 케이스입니다.

단순히 프론트단에서 차단 처리를 하는 건 보안상 문제가 있기 때문에, 이 책임은 **백엔드(Spring Security)**에서 처리하도록 했습니다.

그런데 로그인 실패 시 작동하는 LoginFailureHandler에서는 로그인 실패 응답을 JSON 형식으로 내려주기 위해 Gson을 사용하고 있었는데,
Gson은 LocalDateTime 타입을 기본적으로 처리하지 못해서 예외가 발생했습니다.

그래서 해결 방법으로, 로그인 실패 처리 부분(LoginFailureHandler)에서만 Jackson(ObjectMapper)을 사용하도록 바꿨고,
그 결과 LocalDateTime도 문제없이 직렬화되면서 JSON 응답을 안정적으로 내려줄 수 있게 되었습니다.


=============================================================
문제는 Redux Toolkit의 직렬화 과정에서 커스텀 객체 속성들이 손실되는 것이었습니다.

문제 분석:
CustomAuthenticationProvider에서 BannedMemberException 정상 발생
APILoginFailHandler에서 403 상태와 밴 정보 정상 응답
Jackson으로 LocalDateTime 직렬화 문제도 해결
프론트엔드 API 계층: 정상 작동 ✅

memberApi.jsx에서 403 에러 감지
BannedMemberException 생성하여 banInfo, isBannedMember 속성 추가
문제 지점: Redux Toolkit의 createAsyncThunk ❌

Redux Toolkit은 에러 객체를 직렬화할 때 표준 Error 속성만 유지
커스텀 속성 (banInfo, isBannedMember)은 손실됨
해결 방법:
조건을 단순화해서 error.message === "MEMBER_BANNED"만으로 밴된 회원을 식별하도록 수정했습니다:

// 이전 (작동 안 함)
if (error.isBannedMember || (error.message === "MEMBER_BANNED" && error.banInfo))

// 수정 후 (작동함!)
if (error.message === "MEMBER_BANNED")

그리고 banInfo가 없을 때는 기본값을 제공하여 모달이 열리도록 했습니다.

교훈:
Redux Toolkit을 사용할 때는 에러 객체의 커스텀 속성이 직렬화 과정에서 손실될 수 있다는 점을 항상 염두에 두어야 합니다!


================================================================

🔐 통일된 보안 설정 구조
1. JWTCheckFilter (1차 필터링)
JWT 토큰 검증 및 인증 처리
/api/member/refresh 경로 예외 처리
유효한 토큰을 가진 사용자만 통과
2. CustomSecurityConfig (2차 URL 레벨 보안)
URL 패턴별 접근 권한 설정
permitAll(): 로그인, 회원가입, 토큰 리프레시 등
authenticated(): 게시글 작성/수정/삭제, 댓글 등
hasAnyRole('ADMIN','MANAGER'): 관리자 API
3. @PreAuthorize (3차 메서드 레벨 보안)
통일된 패턴:

일반 기능: @PreAuthorize("hasAnyRole('USER','MANAGER','ADMIN')")

BoardController (게시글 작성/수정/삭제)
ReplyController (댓글 작성/수정/삭제)
FileController (파일 업로드)
MemberController (마이페이지)
SocialController (마이페이지 수정)
관리자 기능: @PreAuthorize("hasAnyRole('ADMIN','MANAGER')")

AdminController 대부분 메서드
최고 관리자 전용: @PreAuthorize("hasRole('ADMIN')")

AdminController의 권한 변경 메서드
4. 프론트엔드 라우트 보호
ProtectedBoard:게시판 의 로그인, 관리자에따른 버튼,링크,컴포넌트 보호
ProtectedAdmin:관리자 페이지의 관리자에 따른 버튼, 링크
ProtectedLogin:로그인에 따른 다양한 파일들의 버튼, 링크, 컴포넌트 보호


========================================================
사용되고 있는 다른 컬렉션 타입들:
1. LinkedHashMap
위치: MemberServiceImpl.java
용도: 카카오 API 응답 데이터 처리
사용 이유:
JSON 응답 데이터를 파싱할 때 사용
삽입 순서를 유지하면서 키-값 쌍을 저장
카카오 로그인 API에서 반환되는 JSON 구조를 처리하기 위해 사용
2. HashMap
위치: MemberDTO.java
용도: JWT 토큰 생성을 위한 Claims 데이터 저장
사용 이유:
JWT 토큰에 포함될 사용자 정보를 Map 형태로 구성
키-값 쌍으로 사용자 정보를 저장 (getClaims() 메서드)
3. Map 인터페이스
위치: 여러 컨트롤러 파일들
용도: API 응답 데이터 구조
사용 이유:
REST API 응답에서 유연한 데이터 구조 제공
JSON 형태의 응답 데이터를 구성할 때 사용

Key(이름표)	Value(내용물)
"name"	"Alice"
"age"	30
"email"	"alice@example.com"
로그인 기능이 포함된 member 기능안에서는 
이런 key-value값이 포함된 JSON형식으로서 사용자의 정보가 지정이 됨 이것을 배열로 사용하기 위해서는 Map선언이 기본적으로 필요합니다.
조금더 세분화해서 복잡한 JSON방식을 처리하는 카카오api부분은 순서대로 정렬해주는게 좋기에 linkedhashmap을 사용합니다.
그 외에 내부 서버에서 토큰을 발급받을때 api의 경우 어짜피 토큰자체가 무작위이기에 순서가 중요하지않아 속도가 더빠른 hashmap을 사용합니다.

key-value는 하나의 세트고 각 세트의 순서에따라 hashmap 혹은 linkedhashmap사용함


========================================================
arraylist/set
map같은경우에는 순서만 지키면 되는 간단 객체의 배열이 전부라 arraylist사용하였습니다.

인덱스 (순서)	사진 이름	설명			파일 경로
0		slide1.jpg	첫 번째 소개 이미지	/images/slide1.jpg
1		slide2.jpg	기능 설명 이미지		/images/slide2.jpg
2		slide3.jpg	사용 방법 이미지		/images/slide3.jpg
3		slide4.jpg	마무리 인사 이미지		/images/slide4.jpg

이런식으로 순서는 필요하지만 간단한 배열일때 arraylist사용 set을 사용한다면 순서가 망가짐



=========================================================


1. Member 테이블 중심의 관계
Member ↔ Board: 1:N (한 회원이 여러 게시글 작성)
Member ↔ Reply: 1:N (한 회원이 여러 댓글 작성)
Member ↔ Banned: 1:N (한 회원이 여러 정지 기록 보유 가능)
2. Board 테이블 중심의 관계
Board ↔ Member: N:1 (여러 게시글이 한 회원에 속함)
Board ↔ BoardImage: 1:N (한 게시글이 여러 이미지 보유)
Board ↔ Reply: 1:N (한 게시글이 여러 댓글 보유)
3. 기타 관계
Reply ↔ Board: N:1 (여러 댓글이 한 게시글에 속함)
Reply ↔ Member: N:1 (여러 댓글이 한 회원에 속함)

정리: 다대일 관계를 사용함
다대다관계는 확장성과 제어측면에서 불리하기에 실무에선 지양하고있음
다만 정 사용해야할 경우에는 중간엔티티를 만들어 양쪽에 다대일을 사용하여 다대다 기능이 가능하게 사용할수는 있음

========================================================

@index

검색시에 속도 향상을 위한
@Index 사용도 고려해봤지만, 현재로서는 특정 컬럼에 검색 부하가 집중되는 경우가 없었고, 인덱스를 과도하게 생성하면 오히려 쓰기 성능이 저하될 수 있기 때문에 본 프로젝트에선 생략했습니다.

=========================================================

웹소켓 세션방식
사용자들이 세션에 등록
메신저 브로커에서 구독한친구들한테 전송

폴링방식
몇초마다 한번씩 서버에서 내용을 받아오는 구조
http
변환
stomp 

ws
http

wss
https

=======================================================

1️⃣ 고객이 채팅 요청

고객이 "채팅 문의" 버튼 클릭

간단한 사전 질문 작성 → DB에 저장

새 채팅방 생성 (상태: WAITING)

서버가 웹소켓으로 관리자에게 알림 전송
→ 관리자 화면에 새 채팅방이 실시간으로 표시됨

2️⃣ 관리자가 상담 시작

관리자가 "상담 시작" 버튼 클릭

채팅방 상태가 WAITING → ACTIVE로 변경

웹소켓으로 두 군데 알림 전송:

고객에게: "상담이 시작되었습니다"

관리자 화면도 갱신

3️⃣ 실시간 채팅 진행

고객이나 관리자가 메시지 입력 → /app/chat/send로 전송

서버는:

메시지를 DB에 저장

웹소켓을 통해 해당 채팅방 구독자에게 브로드캐스트 (/topic/chat/{채팅방번호})

결과적으로, 양쪽 화면이 실시간으로 대화 내용을 갱신

4️⃣ 채팅 종료

관리자가 "채팅 종료" 클릭

채팅방 상태가 ACTIVE → ENDED로 변경

웹소켓으로 고객과 관리자에게 동시에 알림 전송:

고객: "상담이 종료되었습니다" 표시 + 채팅방 비활성화

관리자: 채팅방 상태가 완료로 실시간 업데이트



저희는 현재 Spring 서버 내에 내장된 Simple Broker 방식을 사용하여 채팅 기능을 구현했습니다.

그 이유는 아직 테스트 단계로, 시스템에 큰 부하가 없고, 웹소켓 기반 채팅 기능 자체도 처음 적용해보는 상황이라 구조를 이해하고 기초를 익히기 위한 목적에서 가장 기본적인 방식을 선택했습니다.

다만, 향후 유저 수 증가나 서버 확장 등 트래픽 증가 및 확장성을 고려해야 하는 단계에 도달한다면,
RabbitMQ나 Kafka 같은 외부 메시지 브로커를 도입해 부하 분산, 안정성, 유연한 확장을 도모하는 것이 바람직하다고 판단하고 있습니다.




### 시나리오 1: 관리자가 여러 작업을 할 때
```
관리자 A 로그인
    │
    ├── 🔌 웹소켓 연결 (ws://localhost:8080/ws?access_token=admin_token)
    │   └── ✅ 한 번만 연결, 계속 유지
    │
    ├── 📄 관리자 페이지 접속
    │   └── 📡 구독: /topic/chat/admin/status (모든 관리자 알림)
    │
    ├── 💬 채팅방 123번 입장
    │   ├── 📡 구독 추가: /queue/chat/123 (개별 메시지)
    │   └── 📡 구독 추가: /queue/chat/123/status (개별 상태)
    │
    ├── 💬 채팅방 456번 입장 
    │   ├── 📡 구독 해제: /queue/chat/123, /queue/chat/123/status
    │   ├── 📡 구독 추가: /queue/chat/456 (개별 메시지)
    │   └── 📡 구독 추가: /queue/chat/456/status (개별 상태)
    │
    └── 📄 관리자 페이지로 복귀
        ├── 📡 구독 해제: /queue/chat/456, /queue/chat/456/status  
        └── 📡 구독 유지: /topic/chat/admin/status (계속 관리자 알림 수신)
```

### 시나리오 2: 일반 사용자의 경우
```
사용자 B 로그인
    │
    ├── 🔌 웹소켓 연결 (ws://localhost:8080/ws?access_token=user_token)
    │   └── ✅ 한 번만 연결, 계속 유지
    │
    ├── 💬 고객센터 채팅 시작
    │   ├── 📡 구독: /queue/chat/789 (개별 메시지)
    │   └── 📡 구독: /queue/chat/789/status (개별 상태)
    │
    └── 💬 채팅 종료
        ├── 📡 구독 해제: /queue/chat/789, /queue/chat/789/status
        └── 🔌 웹소켓 연결 유지 (다른 기능에서 재사용)
```

개별메세지는 실제 채팅 내용이 오가는 용도
개별 상태는 채팅방의 상태 변화를 알려주는 시스템

